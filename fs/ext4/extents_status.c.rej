diff a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c	(rejected hunks)
@@ -144,6 +145,383 @@
 static struct kmem_cache *ext4_es_cachep;
 static struct kmem_cache *ext4_pending_cachep;
 
+struct xrp_extent *xrp_do_search_extent(struct rb_root *root, __u32 lblk)
+{
+	/* return the left-most extent that *might* overlap with the input extent,
+	 * assuming the extents in the tree do not overlap
+	 */
+	struct rb_node *node = root->rb_node;
+	struct xrp_extent *i_extent = NULL;
+
+	while (node) {
+		i_extent = rb_entry(node, struct xrp_extent, rb_node);
+		if (lblk < i_extent->lblk)
+			node = node->rb_left;
+		else if (lblk > i_extent->lblk + i_extent->len - 1)
+			node = node->rb_right;
+		else
+			return i_extent;
+	}
+
+	if (i_extent && lblk < i_extent->lblk)
+		return i_extent;
+
+	if (i_extent && lblk > i_extent->lblk + i_extent->len - 1) {
+		node = rb_next(&i_extent->rb_node);
+		return node ? rb_entry(node, struct xrp_extent, rb_node) :
+			      NULL;
+	}
+
+	return NULL;
+}
+
+bool xrp_extent_can_merge(struct xrp_extent *i_extent_left,
+                          struct xrp_extent *i_extent_right)
+{
+	if (((__u64) i_extent_left->len) + i_extent_right->len > XRP_MAX_LEN) {
+		pr_warn("xrp assertion failed when merging extents. "
+			"The sum of lengths of i_extent_left (%d) and i_extent_right (%d) "
+			"is bigger than allowed file size (%d)\n",
+			i_extent_left->len, i_extent_right->len, XRP_MAX_LEN);
+		WARN_ON(1);
+		return false;
+	}
+
+	if (((__u64) i_extent_left->lblk) + i_extent_left->len != i_extent_right->lblk)
+		return false;
+
+	if (i_extent_left->pblk + i_extent_left->len != i_extent_right->pblk)
+		return false;
+
+	return true;
+}
+
+void xrp_do_try_merge_left(struct rb_root *root,
+                           struct xrp_extent *i_extent)
+{
+	struct rb_node *node;
+	struct xrp_extent *left_i_extent;
+
+	node = rb_prev(&i_extent->rb_node);
+	if (!node)
+		return;
+
+	left_i_extent = rb_entry(node, struct xrp_extent, rb_node);
+	if (xrp_extent_can_merge(left_i_extent, i_extent)) {
+		left_i_extent->len += i_extent->len;
+		rb_erase(&i_extent->rb_node, root);
+		kfree(i_extent);
+	}
+}
+
+void xrp_do_try_merge_right(struct rb_root *root,
+                            struct xrp_extent *i_extent)
+{
+	struct rb_node *node;
+	struct xrp_extent *right_i_extent;
+
+	node = rb_next(&i_extent->rb_node);
+	if (!node)
+		return;
+
+	right_i_extent = rb_entry(node, struct xrp_extent, rb_node);
+	if (xrp_extent_can_merge(i_extent, right_i_extent)) {
+		i_extent->len += right_i_extent->len;
+		rb_erase(node, root);
+		kfree(right_i_extent);
+	}
+}
+
+int xrp_do_insert_extent(struct rb_root *root,
+                         struct xrp_extent *new_i_extent)
+{
+	/* assumption: new_i_extent does not overlap with any extent in the tree */
+	struct rb_node **p = &root->rb_node;
+	struct rb_node *parent = NULL;
+	struct xrp_extent *i_extent = NULL;
+	int ret = 0;
+
+	while (*p) {
+		parent = *p;
+		i_extent = rb_entry(parent, struct xrp_extent, rb_node);
+
+		if (new_i_extent->lblk < i_extent->lblk) {
+			if (xrp_extent_can_merge(new_i_extent, i_extent)) {
+				i_extent->lblk = new_i_extent->lblk;
+				i_extent->len += new_i_extent->len;
+				i_extent->pblk = new_i_extent->pblk;
+				xrp_do_try_merge_left(root, i_extent);
+				goto out;
+			}
+			p = &((*p)->rb_left);
+		} else if (new_i_extent->lblk > i_extent->lblk + i_extent->len - 1) {
+			if (xrp_extent_can_merge(i_extent, new_i_extent)) {
+				i_extent->len += new_i_extent->len;
+				xrp_do_try_merge_right(root, i_extent);
+				goto out;
+			}
+			p = &((*p)->rb_right);
+		} else {
+			BUG();
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	i_extent = kmalloc(sizeof(struct xrp_extent), GFP_NOIO);
+	if (!i_extent) {
+		printk("xrp: failed to allocate xrp_extent in xrp_do_insert_extent\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	i_extent->lblk = new_i_extent->lblk;
+	i_extent->len = new_i_extent->len;
+	i_extent->pblk = new_i_extent->pblk;
+	i_extent->version = 0;
+	rb_link_node(&i_extent->rb_node, parent, p);
+	rb_insert_color(&i_extent->rb_node, root);
+
+out:
+	return ret;
+}
+
+int xrp_do_remove_extent(struct rb_root *root, __u32 lblk, __u32 len)
+{
+	struct xrp_extent *i_extent;
+	int ret = 0;
+
+	while (true) {
+		i_extent = xrp_do_search_extent(root, lblk);
+		if (!i_extent || i_extent->lblk > lblk + len - 1)
+			break;
+
+		if (i_extent->lblk < lblk && i_extent->lblk + i_extent->len - 1 <= lblk + len - 1) {
+			i_extent->len = lblk - i_extent->lblk;
+		} else if (i_extent->lblk + i_extent->len - 1 > lblk + len - 1 && i_extent->lblk >= lblk) {
+			struct xrp_extent ori_i_extent;
+			ori_i_extent.lblk = i_extent->lblk;
+			ori_i_extent.len = i_extent->len;
+			ori_i_extent.pblk = i_extent->pblk;
+
+			i_extent->lblk = lblk + len;
+			i_extent->len = ori_i_extent.lblk + ori_i_extent.len - lblk - len;
+			i_extent->pblk = ori_i_extent.pblk + (lblk + len - ori_i_extent.lblk);
+		} else if (i_extent->lblk < lblk && i_extent->lblk + i_extent->len - 1 > lblk + len - 1) {
+			__u32 ori_len = i_extent->len;
+			struct xrp_extent new_i_extent;
+			new_i_extent.lblk = lblk + len;
+			new_i_extent.len = i_extent->lblk + i_extent->len - lblk - len;
+			new_i_extent.pblk = i_extent->pblk + (lblk + len - i_extent->lblk);
+
+			i_extent->len = lblk - i_extent->lblk;
+			ret = xrp_do_insert_extent(root, &new_i_extent);
+			if (ret) {
+				printk("xrp: failed to insert extent in xrp_do_remove_extent\n");
+				i_extent->len = ori_len;
+				goto out;
+			}
+		} else {
+			rb_erase(&i_extent->rb_node, root);
+			kfree(i_extent);
+		}
+	}
+
+out:
+	return ret;
+}
+
+void xrp_set_version(struct rb_root *new_root, struct rb_root *old_root, __u64 new_version)
+{
+	struct rb_node *new_tree_node = NULL;
+	struct rb_node *old_tree_node = NULL;
+
+	struct xrp_extent *new_tree_i_extent;
+	struct xrp_extent *old_tree_i_extent;
+	struct xrp_extent *parent_i_extent;
+
+	if (new_root != NULL)
+		new_tree_node = rb_first(new_root);
+	if (old_root != NULL)
+		old_tree_node = rb_first(old_root);
+
+	while (new_tree_node) {
+		new_tree_i_extent = rb_entry(new_tree_node, struct xrp_extent, rb_node);
+		parent_i_extent = NULL;
+		while (old_tree_node) {
+			old_tree_i_extent = rb_entry(old_tree_node, struct xrp_extent, rb_node);
+			if (old_tree_i_extent->lblk + old_tree_i_extent->len <= new_tree_i_extent->lblk) {
+				old_tree_node = rb_next(old_tree_node);
+				continue;
+			}
+			if ((old_tree_i_extent->lblk <= new_tree_i_extent->lblk)
+			    && (old_tree_i_extent->lblk + old_tree_i_extent->len
+			        >= new_tree_i_extent->lblk + new_tree_i_extent->len)
+			    && (new_tree_i_extent->pblk
+			        == old_tree_i_extent->pblk
+			           + (new_tree_i_extent->lblk - old_tree_i_extent->lblk))) {
+				parent_i_extent = old_tree_i_extent;
+			}
+			break;
+		}
+		if (parent_i_extent)
+			new_tree_i_extent->version = parent_i_extent->version;
+		else
+			new_tree_i_extent->version = new_version;
+		new_tree_node = rb_next(new_tree_node);
+	}
+}
+
+void xrp_do_clear_tree(struct rb_root *root)
+{
+	struct rb_node *node;
+	struct xrp_extent *i_extent;
+
+	node = rb_first(root);
+	while (node) {
+		i_extent = rb_entry(node, struct xrp_extent, rb_node);
+		node = rb_next(node);
+		rb_erase(&i_extent->rb_node, root);
+		kfree(i_extent);
+	}
+}
+
+void xrp_rcu_free(struct rcu_head *rcu_head)
+{
+	struct xrp_root *i_root = container_of(rcu_head, struct xrp_root, rcu_head);
+	xrp_do_clear_tree(&i_root->rb_root);
+	kfree(i_root);
+}
+
+void xrp_sync_ext4_extent(struct inode *inode, bool lock_inode)
+{
+	struct xrp_root *new_i_root, *old_i_root;
+	struct rb_root *new_root, *old_root;
+
+	if (lock_inode)
+		read_lock(&EXT4_I(inode)->i_es_lock);
+	spin_lock(&inode->xrp_extent_lock);
+
+	new_i_root = kmalloc(sizeof(struct xrp_root), GFP_NOIO);
+	if (!new_i_root) {
+		printk("xrp: failed to allocate new tree root");
+		goto unlock;
+	}
+	new_i_root->rb_root = RB_ROOT;
+	new_root = &new_i_root->rb_root;
+
+	if (EXT4_I(inode)->i_es_tree.root.rb_node) {
+		struct extent_status *pos, *n;
+		rbtree_postorder_for_each_entry_safe(pos, n, &EXT4_I(inode)->i_es_tree.root, rb_node) {
+			if (ext4_es_is_written(pos) && !ext4_es_is_delayed(pos)) {
+				struct xrp_extent i_extent;
+				int ret;
+
+				i_extent.lblk = pos->es_lblk;
+				i_extent.len = pos->es_len;
+				i_extent.pblk = ext4_es_pblock(pos);
+				ret = xrp_do_insert_extent(new_root, &i_extent);
+				if (ret) {
+					printk("xrp: failed to insert extent\n");
+				}
+			}
+		}
+	}
+
+	old_root = inode->xrp_extent_root;
+	if (old_root) {
+		old_i_root = container_of(old_root, struct xrp_root, rb_root);
+		new_i_root->version = old_i_root->version + 1;
+	} else {
+		new_i_root->version = 0;
+	}
+	xrp_set_version(new_root, old_root, new_i_root->version);
+	rcu_assign_pointer(inode->xrp_extent_root, new_root);
+	if (old_root) {
+		call_rcu(&old_i_root->rcu_head, xrp_rcu_free);
+	}
+unlock:
+	spin_unlock(&inode->xrp_extent_lock);
+	if (lock_inode)
+		read_unlock(&EXT4_I(inode)->i_es_lock);
+}
+
+void xrp_print_tree(struct inode *inode)
+{
+	struct rb_root *root;
+	struct rb_node *node;
+	unsigned long num_extents = 0;
+
+	rcu_read_lock();
+
+	printk("xrp extent tree: (sizeof(struct xrp_extent)=%ld)\n",
+	       sizeof(struct xrp_extent));
+	root = rcu_dereference(inode->xrp_extent_root);
+	if (!root)
+		goto out;
+	node = rb_first(root);
+	while (node) {
+		struct xrp_extent *i_extent;
+		i_extent = rb_entry(node, struct xrp_extent, rb_node);
+		printk("  [%u, %u): %llu\n",
+		       i_extent->lblk, i_extent->lblk + i_extent->len,
+		       i_extent->pblk);
+		++num_extents;
+		node = rb_next(node);
+	}
+out:
+	printk("  total number of extents: %lu\n", num_extents);
+
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(xrp_print_tree);
+
+void xrp_clear_tree(struct inode *inode)
+{
+	struct rb_root *root;
+
+	spin_lock(&inode->xrp_extent_lock);
+	root = inode->xrp_extent_root;
+	rcu_assign_pointer(inode->xrp_extent_root, NULL);
+	if (root) {
+		struct xrp_root *i_root = container_of(root, struct xrp_root, rb_root);
+		call_rcu(&i_root->rcu_head, xrp_rcu_free);
+	}
+	spin_unlock(&inode->xrp_extent_lock);
+}
+EXPORT_SYMBOL(xrp_clear_tree);
+
+void xrp_retrieve_mapping(struct inode *inode, loff_t offset, loff_t len, struct xrp_mapping *mapping)
+{
+	struct rb_root *root;
+	__u64 i_lblk_start, i_lblk_end;
+	struct xrp_extent *i_extent;
+
+	i_lblk_start = offset >> XRP_BLOCK_SHIFT;
+	i_lblk_end = (offset + len - 1) >> XRP_BLOCK_SHIFT;
+
+	rcu_read_lock();
+	root = rcu_dereference(inode->xrp_extent_root);
+	if (root)
+		i_extent = xrp_do_search_extent(root, i_lblk_start);
+	else
+		i_extent = NULL;
+	if (!i_extent || i_extent->lblk > i_lblk_end) {
+		mapping->exist = false;
+	} else {
+		loff_t in_extent_offset = offset - (((u64)i_extent->lblk) << XRP_BLOCK_SHIFT);
+		loff_t in_extent_len = min(len, (((u64)i_extent->len) << XRP_BLOCK_SHIFT)
+		                                - in_extent_offset);
+
+		mapping->exist = true;
+		mapping->offset = offset;
+		mapping->len = in_extent_len;
+		mapping->address = (i_extent->pblk << XRP_BLOCK_SHIFT) + in_extent_offset;
+		mapping->version = i_extent->version;
+	}
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(xrp_retrieve_mapping);
+
 static int __es_insert_extent(struct inode *inode, struct extent_status *newes);
 static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,
 			      ext4_lblk_t end, int *reserved);
